# [삼성] 승자독식 모노폴리

1. 항상 70% 만 한다 스스로 해야돼 

```protobuf
from collections import defaultdict

n, m, k = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(n)]

# 위, 아래, 왼쪽, 오른쪽 = 1,2,3,4
d = [0] + list(map(int, input().split()))

score = [list(map(int, input().split())) for _ in range(m * 4)]

# loc: [상어ID, 현재방향, 경로스택[[x,y], ...]]
loc = []
# board: 각 칸의 냄새 [owner, remain]
board = [[[0, 0] for _ in range(n)] for _ in range(n)]

for i in range(n):
    for j in range(n):
        if arr[i][j] != 0:
            board[i][j] = [arr[i][j], k]
            loc.append([arr[i][j], d[arr[i][j]], [[i, j]]])

loc.sort(key=lambda x: x[0])

dx = [(0, 0), (-1, 0), (1, 0), (0, -1), (0, 1)]
done = []
ck = False
cnt = 0

for idx in range(1, 1001):

    check = defaultdict(list)

    cnt += 1

    # 1) 이동 결정 (기존 냄새 기준)
    for i in loc:
        value, direction, path = i
        if value in done:
            continue
        sx, sy = path[-1]
        row = (value - 1) * 4 + (direction - 1)  # 우선순위 행 (0-index)

        moved = False
        # 1-1) 냄새 없는 칸 우선
        for j in range(4):
            ndir = score[row][j]
            nx, ny = sx + dx[ndir][0], sy + dx[ndir][1]
            if 0 <= nx < n and 0 <= ny < n and board[nx][ny][1] == 0:
                loc[value - 1][2].append([nx, ny])
                loc[value - 1][1] = ndir
                check[(nx, ny)].append(value)
                moved = True
                break

        # 1-2) 없으면 자기 냄새 칸
        if not moved:
            for j in range(4):
                ndir = score[row][j]
                nx, ny = sx + dx[ndir][0], sy + dx[ndir][1]
                if 0 <= nx < n and 0 <= ny < n and board[nx][ny][0] == value and board[nx][ny][1] > 0:
                    loc[value - 1][2].append([nx, ny])
                    loc[value - 1][1] = ndir
                    check[(nx, ny)].append(value)
                    break

    # 2) 충돌 정리: 승자만 남김, 패자 되돌리기
    winners = []
    for (r, c), ids in check.items():
        ids.sort()  # 번호 작은 상어 생존
        winner = ids[0]
        winners.append((r, c, winner))
        for sid in ids[1:]:
            if sid not in done:
                done.append(sid)
                if loc[sid - 1][2]:
                    loc[sid - 1][2].pop()  # 방금 이동 취소

    # 3) 기존 냄새 1 감소
    for r in range(n):
        for c in range(n):
            if board[r][c][1] > 0:
                board[r][c][1] -= 1
                if board[r][c][1] == 0:
                    board[r][c][0] = 0

    # 4) 승자 칸에 새 냄새 k
    for r, c, w in winners:
        board[r][c] = [w, k]

    # 5) 종료 판단 (원 코드 유지)
    for i in range(2, m + 1):
        if i in done:
            continue
        else:
            if cnt == 1000:
                print(-1)
                ck = True
            break
    else:
        if 1 in done:
            print(-1)
            ck = True
        else:
            print(cnt)
            ck = True

    if ck:
        break
else:
    print(-1)

```
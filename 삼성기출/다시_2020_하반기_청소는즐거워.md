# [2020 하반기 삼성] 청소는 즐거워

1. 이거 어려워 근데 ㅎㄹ 수 있음 gpt 

```protobuf
n=int(input())
grid=[
    list(map(int,input().split()))
    for _ in range(n)
]

curr_x,curr_y=n//2,n//2
move_dir, move_num =0,1
ans=0

# 왼 아래 오른쪽 위
dust_ratio=[
    [
        [0, 0, 2, 0, 0],
        [0, 10, 7, 1, 0],
        [5, 0, 0, 0, 0],
        [0, 10, 7, 1, 0],
        [0, 0, 2, 0, 0],
    ],
    [
        [0, 0, 0, 0, 0],
        [0, 1, 0, 1, 0],
        [2, 7, 0, 7, 2],
        [0, 10, 0, 10, 0],
        [0, 0, 5, 0, 0],
    ],
    [
        [0, 0, 2, 0, 0],
        [0, 1, 7, 10, 0],
        [0, 0, 0, 0, 5],
        [0, 1, 7, 10, 0],
        [0, 0, 2, 0, 0],
    ],
    [
        [0, 0, 5, 0, 0],
        [0, 10, 0, 10, 0],
        [2, 7, 0, 7, 2],
        [0, 1, 0, 1, 0],
        [0, 0, 0, 0, 0],
    ]

]

def add_dust(x,y,dust):
    global ans

    if not (0 <= x< n and 0 <= y < n):
        ans+=dust
    else:
        grid[x][y]+=dust

def move():
    global curr_x, curr_y, ans

    # 방향 정의는 그대로 둡니다.
    dxs, dys = [0, 1, 0, -1], [-1, 0, 1, 0]

    # curr 위치를 계산합니다.
    curr_x, curr_y = curr_x + dxs[move_dir], curr_y + dys[move_dir]

    # 1. 이동한 위치의 먼지 양을 임시 변수에 저장합니다.
    original_dust = grid[curr_x][curr_y]

    # 2. 원래 위치의 먼지를 0으로 만듭니다.
    grid[curr_x][curr_y] = 0

    # 3. 임시 변수에 저장된 먼지 양을 기준으로 분배합니다.
    added_dust = 0
    for i in range(5):
        for j in range(5):
            dust = original_dust * dust_ratio[move_dir][i][j] // 100
            add_dust(curr_x + i - 2, curr_y + j - 2, dust)

            added_dust += dust

    # 4. 남은 먼지를 a% 자리에 추가합니다.
    add_dust(curr_x + dxs[move_dir], curr_y + dys[move_dir],
             original_dust - added_dust)

while True:
    for _ in range(move_num):
        move()
        if curr_x == 0 and curr_y == 0:
            # (0, 0)에 도착하면 루프를 종료합니다.
            break

    if curr_x == 0 and curr_y == 0:
        # 이중 루프이므로 바깥 루프도 종료합니다.
        break

    move_dir = (move_dir + 1) % 4
    if move_dir == 0 or move_dir == 2:
        move_num += 1

print(ans)
```
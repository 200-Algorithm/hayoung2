# [ë°±ì¤€] ì§€ë¦„ê¸¸

1. ì‹¤íŒ¨ (ê·¸ë¦¬ë””ë°©ì‹ìœ¼ë¡œ í•¨, í…Œì¼€ 1ë§Œ ë§ê³  ë‹¤ í‹€ë¦¼ ã… )

```python
n,d= map(int,input().split())
# 2ì°¨ì› ì´ˆê¸°í™” í•˜ëŠ” ë¶€ë¶„ ìƒê°
arr = [[] for _ in range(10000)]

for i in range(n):
    a,b,c=map(int,input().split())

    for j in range(len(arr[a])):
        if arr[a][j][0]==b:
            if arr[a][j][1]>c:
                arr[a][j][1]=c
            break
    else:
        arr[a].append([b,c])

tmp=0
result=0
print(arr)
while True:
    if tmp==d:
        break
    for i in range(len(arr[tmp])):
        if arr[tmp][i][0] <=d and ((arr[tmp][i][0]-tmp) >= arr[tmp][i][1]):
            result+=arr[tmp][i][1]
            tmp = arr[tmp][i][0]
            break
    else:
        tmp +=1
        result+=1
    print(tmp,end=' ')
    print(result)

print(result)
```

1. DP ë°©ì‹

```python
n, d = map(int, input().split())
arr = [[] for _ in range(d + 1)]  # ê±°ë¦¬ dê¹Œì§€ë§Œ ë³´ë©´ ë¨

for _ in range(n):
    a, b, c = map(int, input().split())
    if b > d:  # ë„ì°©ë³´ë‹¤ ë©€ë©´ ë¬´ì‹œ
        continue
    arr[a].append((b, c))  # ì¶œë°œì§€ì— (ë„ì°©ì§€, ë¹„ìš©) ì €ì¥

INF = int(1e9)
dp = [INF] * (d + 1) 
dp[0] = 0 # ê±°ë¦¬ 0

# ëª¨ë“  êµ¬ê°„ ì„¤ì • 
for i in range(d + 1):
    if i > 0:
        dp[i] = min(dp[i], dp[i - 1] + 1)  # ì¼ë°˜ ë„ë¡œë¡œ 1 ì´ë™
    for b, c in arr[i]:  # ì§€ë¦„ê¸¸ì´ ìˆë‹¤ë©´
        if dp[b] > dp[i] + c: # í…Œì¼€ 2,3 ê°€ëŠ¥ í˜„ì¬ ê°’ì´ ë” í¬ë©´ ì§€ë¦„ê¸¸ + í•´ì„œ ë°”ê¿ˆ  
            dp[b] = dp[i] + c

print(dp[d])

```

1. ë‹¤ìµìŠ¤íŠ¸ë¼ ë°©ì‹ 

```python
import heapq
n, d = map(int, input().split())
arr = [[] for _ in range(d + 1)]  # ê±°ë¦¬ dê¹Œì§€ë§Œ ë³´ë©´ ë¨

# ëª¨ë“  ë„ë¡œ ê°„ì„  ë¹„ìš© 1ë¡œ ì„¤ì • ê±°ë¦¬ +1 ì´ë‹ˆê¹Œ
for i in range(d):
    arr[i].append((i+1,1))

for i in range(n):
    a,b,c=map(int,input().split())
    if b<=d :
        arr[a].append((b,c))

# ë‹¤ìµìŠ¤íŠ¸ë¼ ì´ˆê¸°í™”
distance = [int(1e9)] * (d + 1)
distance[0] = 0
heap = [(0, 0)]  # (ê±°ë¦¬, ë…¸ë“œ)

# ğŸ“ Step 1: (0, 0) êº¼ëƒ„
# â†’ now=0, dist=0
# â†’ ì¼ë°˜ ë„ë¡œë¡œ 1ê¹Œì§€ ê±°ë¦¬ 1, ì§€ë¦„ê¸¸ë¡œ 5(1) / 10(2) ê°€ëŠ¥
#
# distance[1] = 1 â†’ í™ì— (1, 1)
#
# distance[5] = 1 â†’ í™ì— (1, 5)
#
# distance[10] = 2 â†’ í™ì— (2, 10)
#
# heap = [(1,1), (1,5), (2,10)]
#
# ğŸ“ Step 2: (1, 1) êº¼ëƒ„
# â†’ ì¼ë°˜ ë„ë¡œë¡œ 2ê¹Œì§€ ê±°ë¦¬ 2
#
# distance[2] = 2 â†’ í™ì— (2, 2)
#
# heap = [(1,5), (2,10), (2,2)]
#
# ğŸ“ Step 3: (5, 1) êº¼ëƒ„
# â†’ ì¼ë°˜ ë„ë¡œë¡œ 6ê¹Œì§€ ê±°ë¦¬ 2, ì§€ë¦„ê¸¸ë¡œ 15(3) ìˆìŒ
#
# distance[6] = 2 â†’ í™ì— (2,6)
#
# distance[15] = 4 â†’ í™ì— (4,15)
#
# heap = [(2,2), (2,10), (2,6), (4,15)]
#
# ğŸ“ Step 4: (2, 2) êº¼ëƒ„
# â†’ ì¼ë°˜ ë„ë¡œë¡œ 3ê¹Œì§€ ê±°ë¦¬ 3

while heap:
    dist,now=heapq.heappop(heap)
    # í˜„ì¬ ê°’ì´ ê±°ë¦¬ë³´ë‹¤ ë” ì‘ë‹¤ë©´ ê³„ì‚° X
    # ë” ì•ˆì¢‹ì€ ê²½ë¡œ ë²„ë¦¼
    if distance[now] < dist:
        continue

    for next_node, cost in arr[now]:
        if distance[next_node] > dist+ cost:
            distance[next_node] =dist+cost
            heapq.heappush(heap,(distance[next_node],next_node))
print(distance[d])
```
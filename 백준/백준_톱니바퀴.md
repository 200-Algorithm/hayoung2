# [백준] 톱니바퀴

1. gpt

```protobuf
import sys
from collections import deque

input = sys.stdin.readline

# 4개의 톱니: 각 톱니는 8칸으로 이루어짐 (deque 사용 → 회전 연산 효율적)
gears = [deque(input().strip()) for _ in range(4)]

K = int(input())  # 회전 명령 개수
# ops: (톱니번호, 회전방향) 튜플 리스트
# 톱니번호: 1~4, 회전방향: 1(시계), -1(반시계)
ops = [tuple(map(int, input().split())) for _ in range(K)]

def rotate_gear(dq, d):
    # deque의 rotate 메서드 사용
    # d=1 → 시계 방향으로 1칸 회전
    # d=-1 → 반시계 방향으로 1칸 회전
    dq.rotate(d)

for g, d in ops:
    g -= 1  # 입력은 1~4, 내부 인덱스는 0~3으로 맞추기

    # 현재 상태에서 맞닿는 치아가 같은지/다른지 미리 저장
    # i의 2번 인덱스(오른쪽 치아) vs i+1의 6번 인덱스(왼쪽 치아)
    contact_diff = [False] * 3
    for i in range(3):
        contact_diff[i] = (gears[i][2] != gears[i+1][6])

    # 이번 회전에서 각 톱니가 어떤 방향으로 돌지 기록할 배열
    # 0이면 회전 안 함
    dirs = [0] * 4
    dirs[g] = d  # 현재 명령받은 톱니 방향 지정

    # 왼쪽으로 연쇄 전파
    cur = g
    while cur-1 >= 0:
        if contact_diff[cur-1]:
            # 맞닿은 극이 다르면 반대 방향으로 회전
            dirs[cur-1] = -dirs[cur]
            cur -= 1
        else:
            # 극이 같으면 연쇄 전파 중단
            break

    # 오른쪽으로 연쇄 전파
    cur = g
    while cur+1 <= 3:
        if contact_diff[cur]:
            dirs[cur+1] = -dirs[cur]
            cur += 1
        else:
            break

    # 전파 결과에 따라 모든 톱니를 한 번에 회전
    for i in range(4):
        if dirs[i] != 0:
            rotate_gear(gears[i], dirs[i])

# 점수 계산
# 각 톱니의 12시 방향(0번 인덱스)이 '1'이면 점수 부여
# 1번 톱니: 1점, 2번: 2점, 3번: 4점, 4번: 8점
score = 0
for i in range(4):
    if gears[i][0] == '1':
        score += (1 << i)  # 1,2,4,8 가중치 더하기

print(score)

```